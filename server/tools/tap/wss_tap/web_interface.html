<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WSS Raw Media Tap - Audio Stream Monitor</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 20px;
        }

        .container {
            background: white;
            border-radius: 16px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
            max-width: 800px;
            width: 100%;
            padding: 40px;
        }

        .header {
            text-align: center;
            margin-bottom: 30px;
        }

        .header h1 {
            color: #667eea;
            font-size: 28px;
            margin-bottom: 8px;
        }

        .header p {
            color: #666;
            font-size: 14px;
        }

        .status-bar {
            background: #f8f9fa;
            border-radius: 8px;
            padding: 20px;
            margin-bottom: 30px;
            border: 2px solid #e9ecef;
        }

        .status-item {
            display: flex;
            justify-content: space-between;
            padding: 8px 0;
            border-bottom: 1px solid #e9ecef;
        }

        .status-item:last-child {
            border-bottom: none;
        }

        .status-label {
            font-weight: 600;
            color: #495057;
        }

        .status-value {
            color: #212529;
            font-family: 'Courier New', monospace;
        }

        .status-indicator {
            display: inline-block;
            width: 12px;
            height: 12px;
            border-radius: 50%;
            margin-right: 8px;
        }

        .status-indicator.disconnected {
            background: #dc3545;
        }

        .status-indicator.connected {
            background: #28a745;
            animation: pulse 2s ease-in-out infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        .controls {
            text-align: center;
            margin-bottom: 30px;
        }

        .volume-control {
            margin: 20px auto;
            max-width: 400px;
        }

        .volume-label {
            display: flex;
            justify-content: space-between;
            margin-bottom: 8px;
            font-size: 14px;
            color: #495057;
        }

        .volume-slider {
            width: 100%;
            height: 6px;
            border-radius: 3px;
            background: #e9ecef;
            outline: none;
            -webkit-appearance: none;
        }

        .volume-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            cursor: pointer;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
        }

        .volume-slider::-moz-range-thumb {
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            cursor: pointer;
            border: none;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
        }

        .play-button {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            border-radius: 50px;
            padding: 16px 48px;
            font-size: 18px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(102, 126, 234, 0.4);
        }

        .play-button:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(102, 126, 234, 0.6);
        }

        .play-button:disabled {
            background: #6c757d;
            cursor: not-allowed;
            box-shadow: none;
        }

        .play-button.playing {
            background: linear-gradient(135deg, #dc3545 0%, #c82333 100%);
        }

        .visualizer {
            background: #000;
            border-radius: 8px;
            height: 120px;
            margin-bottom: 30px;
            position: relative;
            overflow: hidden;
        }

        #audioCanvas {
            width: 100%;
            height: 100%;
        }

        .stream-info {
            background: #f8f9fa;
            border-radius: 8px;
            padding: 20px;
        }

        .stream-info h3 {
            color: #495057;
            margin-bottom: 15px;
            font-size: 16px;
        }

        .info-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
        }

        .info-card {
            background: white;
            padding: 15px;
            border-radius: 8px;
            border: 1px solid #dee2e6;
        }

        .info-card-label {
            font-size: 12px;
            color: #6c757d;
            text-transform: uppercase;
            margin-bottom: 5px;
        }

        .info-card-value {
            font-size: 20px;
            font-weight: 600;
            color: #212529;
        }

        .log-area {
            background: #212529;
            color: #00ff00;
            border-radius: 8px;
            padding: 15px;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            height: 200px;
            overflow-y: auto;
            margin-top: 20px;
        }

        .log-entry {
            margin-bottom: 4px;
        }

        .log-timestamp {
            color: #6c757d;
        }

        .settings-panel {
            background: #f8f9fa;
            border-radius: 8px;
            padding: 20px;
            margin-top: 20px;
            border: 2px solid #e9ecef;
        }

        .settings-panel h3 {
            color: #495057;
            margin-bottom: 15px;
            font-size: 16px;
        }

        .setting-item {
            margin-bottom: 15px;
        }

        .setting-item label {
            display: block;
            font-size: 13px;
            color: #495057;
            margin-bottom: 5px;
            font-weight: 500;
        }

        .setting-input {
            width: 100%;
            padding: 8px;
            border: 1px solid #dee2e6;
            border-radius: 4px;
            font-size: 13px;
        }

        .setting-description {
            font-size: 11px;
            color: #6c757d;
            margin-top: 3px;
        }

        .settings-buttons {
            display: flex;
            gap: 10px;
            margin-top: 15px;
        }

        .settings-btn {
            padding: 8px 16px;
            border: none;
            border-radius: 4px;
            font-size: 13px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .settings-btn.save {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
        }

        .settings-btn.reset {
            background: #6c757d;
            color: white;
        }

        .settings-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.15);
        }

        /* Calls Table Styles */
        .calls-table { width: 100%; border-collapse: collapse; font-size: 14px; }
        .calls-table thead th { background: #f8f9fa; padding: 12px; text-align: left; border-bottom: 2px solid #dee2e6; font-weight: 600; color: #495057; }
        .calls-table tbody td { padding: 12px; border-bottom: 1px solid #e9ecef; }
        .calls-table tbody tr:hover { background: #f8f9fa; }
        .calls-table tbody tr.playing { background: #e7f5ff; }
        .call-action-btn { padding: 6px 12px; border: none; border-radius: 4px; cursor: pointer; font-size: 12px; font-weight: 500; transition: all 0.2s; }
        .call-action-btn.listen { background: #4CAF50; color: white; }
        .call-action-btn.listen:hover { background: #45a049; }
        .call-action-btn.listening { background: #FFC107; color: #333; }
        .call-action-btn:disabled { opacity: 0.5; cursor: not-allowed; }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>WSS Raw Media Tap</h1>
            <p>Real-time Audio Stream Monitor</p>
        </div>

        <div class="status-bar">
            <div class="status-item">
                <span class="status-label">
                    <span class="status-indicator disconnected" id="statusIndicator"></span>
                    Connection Status
                </span>
                <span class="status-value" id="connectionStatus">Disconnected</span>
            </div>
            <div class="status-item">
                <span class="status-label">WebSocket URL</span>
                <span class="status-value" id="wsUrl">-</span>
            </div>
        </div>

        <div class="controls">
            <button class="play-button" id="playButton" disabled>
                Connect & Play
            </button>

            <button class="play-button" id="testAudioButton">
                🎵 Test Audio
            </button>

            <div class="volume-control">
                <div class="volume-label">
                    <span>Volume</span>
                    <span id="volumeValue">85%</span>
                </div>
                <input type="range" min="0" max="100" value="85" class="volume-slider" id="volumeSlider">
            </div>
        </div>

        <div class="visualizer">
            <canvas id="audioCanvas"></canvas>
        </div>

        <div class="stream-info">
            <h3>Stream Information</h3>
            <div class="info-grid">
                <div class="info-card">
                    <div class="info-card-label">Sample Rate</div>
                    <div class="info-card-value" id="sampleRate">-</div>
                </div>
                <div class="info-card">
                    <div class="info-card-label">Encoding</div>
                    <div class="info-card-value" id="encoding">-</div>
                </div>
                <div class="info-card">
                    <div class="info-card-label">Bytes Received</div>
                    <div class="info-card-value" id="bytesReceived">0</div>
                </div>
                <div class="info-card">
                    <div class="info-card-label">Duration</div>
                    <div class="info-card-value" id="duration">00:00</div>
                </div>
            </div>
        </div>

        <!-- Active Calls Section -->
        <div class="stream-info">
            <h3>Active Calls (<span id="callCount">0</span>)</h3>
            <div id="callsTableContainer">
                <table class="calls-table">
                    <thead>
                        <tr>
                            <th>Call ID</th>
                            <th>Encoding</th>
                            <th>Sample Rate</th>
                            <th>Duration</th>
                            <th>Data</th>
                            <th>Action</th>
                        </tr>
                    </thead>
                    <tbody id="callsTableBody">
                        <tr>
                            <td colspan="6" style="text-align: center; padding: 20px; color: #888;">
                                No active calls. Waiting for connections...
                            </td>
                        </tr>
                    </tbody>
                </table>
            </div>
        </div>

        <div class="log-area" id="logArea"></div>

        <!-- Settings Panel -->
        <div class="settings-panel">
            <h3 style="margin-bottom: 15px; color: #333;">Audio Settings</h3>

            <div class="setting-item">
                <label for="settingsVolume" style="display: block; margin-bottom: 5px; font-weight: 500;">
                    Default Volume (%)
                </label>
                <input
                    type="number"
                    id="settingsVolume"
                    class="setting-input"
                    min="0"
                    max="100"
                    value="85"
                    placeholder="85"
                >
                <small style="color: #666; font-size: 11px;">Default: 85% - Recommended to prevent clipping</small>
            </div>

            <div class="setting-item">
                <label for="settingsStartupBuffer" style="display: block; margin-bottom: 5px; font-weight: 500;">
                    Startup Buffer (ms)
                </label>
                <input
                    type="number"
                    id="settingsStartupBuffer"
                    class="setting-input"
                    min="0"
                    max="1000"
                    value="100"
                    placeholder="100"
                >
                <small style="color: #666; font-size: 11px;">Default: 100ms - Initial buffer before playback starts</small>
            </div>

            <div class="setting-item">
                <label for="settingsRecoveryBuffer" style="display: block; margin-bottom: 5px; font-weight: 500;">
                    Recovery Buffer (ms)
                </label>
                <input
                    type="number"
                    id="settingsRecoveryBuffer"
                    class="setting-input"
                    min="0"
                    max="500"
                    value="50"
                    placeholder="50"
                >
                <small style="color: #666; font-size: 11px;">Default: 50ms - Buffer when playback falls behind</small>
            </div>

            <div class="settings-buttons">
                <button class="settings-btn" id="saveSettingsBtn" style="background: #28a745; color: white;">
                    Save Settings
                </button>
                <button class="settings-btn" id="resetSettingsBtn" style="background: #6c757d; color: white;">
                    Reset to Defaults
                </button>
            </div>

            <div id="settingsStatus" style="margin-top: 10px; padding: 8px; border-radius: 4px; display: none;"></div>
        </div>
    </div>

    <script>
        // μ-law decoding table
        const ULAW_TABLE = new Int16Array([
            -32124, -31100, -30076, -29052, -28028, -27004, -25980, -24956,
            -23932, -22908, -21884, -20860, -19836, -18812, -17788, -16764,
            -15996, -15484, -14972, -14460, -13948, -13436, -12924, -12412,
            -11900, -11388, -10876, -10364,  -9852,  -9340,  -8828,  -8316,
             -7932,  -7676,  -7420,  -7164,  -6908,  -6652,  -6396,  -6140,
             -5884,  -5628,  -5372,  -5116,  -4860,  -4604,  -4348,  -4092,
             -3900,  -3772,  -3644,  -3516,  -3388,  -3260,  -3132,  -3004,
             -2876,  -2748,  -2620,  -2492,  -2364,  -2236,  -2108,  -1980,
             -1884,  -1820,  -1756,  -1692,  -1628,  -1564,  -1500,  -1436,
             -1372,  -1308,  -1244,  -1180,  -1116,  -1052,   -988,   -924,
              -876,   -844,   -812,   -780,   -748,   -716,   -684,   -652,
              -620,   -588,   -556,   -524,   -492,   -460,   -428,   -396,
              -372,   -356,   -340,   -324,   -308,   -292,   -276,   -260,
              -244,   -228,   -212,   -196,   -180,   -164,   -148,   -132,
              -120,   -112,   -104,    -96,    -88,    -80,    -72,    -64,
               -56,    -48,    -40,    -32,    -24,    -16,     -8,      0,
             32124,  31100,  30076,  29052,  28028,  27004,  25980,  24956,
             23932,  22908,  21884,  20860,  19836,  18812,  17788,  16764,
             15996,  15484,  14972,  14460,  13948,  13436,  12924,  12412,
             11900,  11388,  10876,  10364,   9852,   9340,   8828,   8316,
              7932,   7676,   7420,   7164,   6908,   6652,   6396,   6140,
              5884,   5628,   5372,   5116,   4860,   4604,   4348,   4092,
              3900,   3772,   3644,   3516,   3388,   3260,   3132,   3004,
              2876,   2748,   2620,   2492,   2364,   2236,   2108,   1980,
              1884,   1820,   1756,   1692,   1628,   1564,   1500,   1436,
              1372,   1308,   1244,   1180,   1116,   1052,    988,    924,
               876,    844,    812,    780,    748,    716,    684,    652,
               620,    588,    556,    524,    492,    460,    428,    396,
               372,    356,    340,    324,    308,    292,    276,    260,
               244,    228,    212,    196,    180,    164,    148,    132,
               120,    112,    104,     96,     88,     80,     72,     64,
                56,     48,     40,     32,     24,     16,      8,      0
        ]);

        function decodeMulaw(mulawData) {
            const pcmData = new Int16Array(mulawData.length);
            for (let i = 0; i < mulawData.length; i++) {
                pcmData[i] = ULAW_TABLE[mulawData[i]];
            }
            return pcmData;
        }

        // Audio Settings Management
        const SETTINGS_KEY = 'wss_tap_audio_settings';
        const DEFAULT_SETTINGS = {
            volume: 65,              // 65% volume (reduced from 85% to prevent clipping)
            startupBuffer: 100,      // 100ms startup buffer
            recoveryBuffer: 50       // 50ms recovery buffer
        };

        function loadSettings() {
            try {
                const saved = localStorage.getItem(SETTINGS_KEY);
                if (saved) {
                    const settings = JSON.parse(saved);
                    log('Loaded saved settings from localStorage');
                    return { ...DEFAULT_SETTINGS, ...settings };
                }
            } catch (error) {
                log(`Error loading settings: ${error.message}`, 'error');
            }
            log('Using default settings');
            return { ...DEFAULT_SETTINGS };
        }

        function saveSettings(settings) {
            try {
                localStorage.setItem(SETTINGS_KEY, JSON.stringify(settings));
                log('Settings saved to localStorage');
                return true;
            } catch (error) {
                log(`Error saving settings: ${error.message}`, 'error');
                return false;
            }
        }

        function resetSettings() {
            try {
                localStorage.removeItem(SETTINGS_KEY);
                log('Settings reset to defaults');
                return { ...DEFAULT_SETTINGS };
            } catch (error) {
                log(`Error resetting settings: ${error.message}`, 'error');
                return { ...DEFAULT_SETTINGS };
            }
        }

        function applySettingsToUI(settings) {
            document.getElementById('settingsVolume').value = settings.volume;
            document.getElementById('settingsStartupBuffer').value = settings.startupBuffer;
            document.getElementById('settingsRecoveryBuffer').value = settings.recoveryBuffer;

            // Also update the volume slider
            document.getElementById('volumeSlider').value = settings.volume;
            document.getElementById('volumeValue').textContent = `${settings.volume}%`;
        }

        class AudioStreamPlayer {
            constructor() {
                // Load settings from localStorage
                const settings = loadSettings();

                this.ws = null;
                this.audioContext = null;
                this.analyser = null;
                this.gainNode = null;
                this.isPlaying = false;
                this.sourceSampleRate = 8000;  // Source audio sample rate (from header)
                this.encoding = 'mulaw';  // Audio encoding (mulaw, alaw, pcm)
                this.bytesReceived = 0;
                this.startTime = null;
                this.audioQueue = [];
                this.isProcessing = false;
                this.volume = settings.volume / 100;  // Convert percentage to 0.0-1.0
                this.nextPlayTime = 0;  // Track when the next chunk should play
                this.scheduledChunks = 0;  // Track number of scheduled chunks
                this.playbackStarted = false;  // Track if we've started playback
                this.bufferDelay = settings.startupBuffer / 1000;  // Convert ms to seconds
                this.recoveryBuffer = settings.recoveryBuffer / 1000;  // Convert ms to seconds
            }

            parseContentType(contentType) {
                // Parse content-type header like "audio/mulaw;rate=8000" or "content-type:audio/mulaw;rate=8000"
                try {
                    // Remove "content-type:" prefix if present
                    contentType = contentType.replace(/^content-type:\s*/i, '');

                    // Extract encoding (mulaw, alaw, pcm, etc.)
                    const encodingMatch = contentType.match(/audio\/(\w+)/);
                    if (encodingMatch) {
                        this.encoding = encodingMatch[1].toLowerCase();
                    }

                    // Extract sample rate
                    const rateMatch = contentType.match(/rate=(\d+)/);
                    if (rateMatch) {
                        this.sourceSampleRate = parseInt(rateMatch[1]);
                        log(`Detected sample rate: ${this.sourceSampleRate} Hz`);
                    }

                    // Update display
                    document.getElementById('sampleRate').textContent = `${this.sourceSampleRate} Hz`;

                    const encodingDisplay = {
                        'mulaw': 'μ-law (G.711)',
                        'alaw': 'A-law (G.711)',
                        'pcm': 'PCM',
                        'l16': 'Linear PCM 16-bit'
                    };
                    document.getElementById('encoding').textContent = encodingDisplay[this.encoding] || this.encoding;

                    return true;
                } catch (error) {
                    log(`Error parsing content-type: ${error.message}`, 'error');
                    return false;
                }
            }

            setVolume(volume) {
                this.volume = volume;
                if (this.gainNode) {
                    this.gainNode.gain.value = volume;
                }
            }

            async connect() {
                // Fetch WebSocket URL dynamically from API
                let wsUrl;
                try {
                    // Try to fetch the URL from the server API
                    const response = await fetch('/api/ws-url');
                    if (response.ok) {
                        const data = await response.json();
                        wsUrl = data.ws_url;
                        log(`Fetched WebSocket URL from API: ${wsUrl}`);
                    } else {
                        throw new Error('Failed to fetch URL from API');
                    }
                } catch (error) {
                    // Fallback: construct WebSocket URL from current page location
                    const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
                    const hostname = window.location.hostname;
                    const port = hostname === 'localhost' || hostname === '127.0.0.1' ? ':3000' : '';
                    wsUrl = `${protocol}//${hostname}${port}`;
                    log(`API unavailable, using fallback URL: ${wsUrl}`);
                }

                log(`Connecting to ${wsUrl}...`);
                updateStatus('Connecting...', false);
                document.getElementById('wsUrl').textContent = wsUrl;

                this.ws = new WebSocket(wsUrl);
                this.ws.binaryType = 'arraybuffer';

                this.ws.onopen = () => {
                    log('WebSocket connected');
                    updateStatus('Connected', true);

                    // Initialize display with default values
                    document.getElementById('sampleRate').textContent = `${this.sourceSampleRate} Hz`;
                    const encodingDisplay = {
                        'mulaw': 'μ-law (G.711)',
                        'alaw': 'A-law (G.711)',
                        'pcm': 'PCM',
                        'l16': 'Linear PCM 16-bit'
                    };
                    document.getElementById('encoding').textContent = encodingDisplay[this.encoding] || this.encoding;
                };

                this.ws.onmessage = (event) => {
                    if (event.data instanceof ArrayBuffer) {
                        const mulawData = new Uint8Array(event.data);
                        this.bytesReceived += mulawData.length;
                        document.getElementById('bytesReceived').textContent =
                            (this.bytesReceived / 1024).toFixed(2) + ' KB';

                        if (this.isPlaying) {
                            const pcmData = decodeMulaw(mulawData);
                            this.audioQueue.push(pcmData);
                            this.processAudioQueue();
                        }
                    } else {
                        // Text message - likely format/content-type header
                        log(`Received text message: ${event.data}`);

                        // Try to parse as JSON first
                        try {
                            const data = JSON.parse(event.data);
                            if (data['content-type']) {
                                this.parseContentType(data['content-type']);
                            }
                        } catch {
                            // Not JSON, try parsing as plain text header
                            if (event.data.includes('audio') || event.data.includes('content-type')) {
                                this.parseContentType(event.data);
                            }
                        }
                    }
                };

                this.ws.onerror = (error) => {
                    log(`WebSocket error: ${error.message || 'Unknown error'}`, 'error');
                    updateStatus('Error', false);
                };

                this.ws.onclose = () => {
                    log('WebSocket disconnected');
                    updateStatus('Disconnected', false);
                    this.isPlaying = false;
                    updatePlayButton();
                };
            }

            processAudioQueue() {
                if (this.isProcessing || this.audioQueue.length === 0) return;
                this.isProcessing = true;

                // Process all queued chunks
                while (this.audioQueue.length > 0) {
                    const pcmData = this.audioQueue.shift();
                    this.playPCM(pcmData);
                }

                this.isProcessing = false;
            }

            playPCM(pcmData) {
                if (!this.audioContext) {
                    // Create AudioContext at browser's native sample rate
                    this.audioContext = new (window.AudioContext || window.webkitAudioContext)();

                    log(`Browser AudioContext sample rate: ${this.audioContext.sampleRate} Hz`);
                    log(`Source audio sample rate: ${this.sourceSampleRate} Hz`);

                    // Create gain node for volume control
                    this.gainNode = this.audioContext.createGain();
                    this.gainNode.gain.value = this.volume;

                    // Create dynamics compressor to prevent clipping
                    this.compressor = this.audioContext.createDynamicsCompressor();
                    this.compressor.threshold.setValueAtTime(-3, this.audioContext.currentTime);   // Start compressing at -3dB (gentle limiting)
                    this.compressor.knee.setValueAtTime(6, this.audioContext.currentTime);         // Smooth compression curve
                    this.compressor.ratio.setValueAtTime(8, this.audioContext.currentTime);        // Moderate compression ratio
                    this.compressor.attack.setValueAtTime(0.003, this.audioContext.currentTime);   // Moderate attack (3ms)
                    this.compressor.release.setValueAtTime(0.1, this.audioContext.currentTime);    // 100ms release
                    log('Dynamics compressor enabled: threshold=-3dB, ratio=8:1 (transparent limiting)');

                    // Create analyser for visualization
                    this.analyser = this.audioContext.createAnalyser();
                    this.analyser.fftSize = 2048;

                    // Chain: source -> gain -> compressor -> analyser -> destination
                    this.gainNode.connect(this.compressor);
                    this.compressor.connect(this.analyser);
                    this.analyser.connect(this.audioContext.destination);

                    visualize(this.analyser);

                    // Initialize next play time with buffer delay to prevent underruns
                    this.nextPlayTime = this.audioContext.currentTime + this.bufferDelay;
                    log(`Added ${this.bufferDelay * 1000}ms startup buffer`);
                }

                // Convert Int16Array to Float32Array for Web Audio API
                const float32Data = new Float32Array(pcmData.length);
                for (let i = 0; i < pcmData.length; i++) {
                    float32Data[i] = pcmData[i] / 32768.0;  // Normalize to -1.0 to 1.0
                }

                // Create buffer with SOURCE sample rate, not context sample rate
                // The browser will automatically resample to the context's sample rate
                const audioBuffer = this.audioContext.createBuffer(
                    1,                          // mono
                    float32Data.length,         // number of samples
                    this.sourceSampleRate       // source sample rate (e.g., 8000 Hz)
                );
                audioBuffer.getChannelData(0).set(float32Data);

                const source = this.audioContext.createBufferSource();
                source.buffer = audioBuffer;
                source.connect(this.gainNode);

                // Calculate when this chunk should start playing
                const currentTime = this.audioContext.currentTime;

                // If we're behind schedule (nextPlayTime is in the past), catch up
                // but add a small buffer to prevent immediate underrun
                if (this.nextPlayTime < currentTime) {
                    this.nextPlayTime = currentTime + this.recoveryBuffer;  // Recovery buffer from settings
                    if (!this.playbackStarted) {
                        log('Starting playback with buffer');
                        this.playbackStarted = true;
                    }
                }

                // Schedule this chunk to start at nextPlayTime
                source.start(this.nextPlayTime);

                // Calculate duration of this chunk in seconds
                const chunkDuration = audioBuffer.duration;

                // Schedule next chunk to start right after this one
                this.nextPlayTime += chunkDuration;

                this.scheduledChunks++;

                // Clean up source when done
                source.onended = () => {
                    this.scheduledChunks--;
                };
            }

            async startPlaying() {
                if (!this.ws || this.ws.readyState !== WebSocket.OPEN) {
                    await this.connect();
                }

                this.isPlaying = true;
                this.startTime = Date.now();
                updateDuration();
                log('Started playing audio');
            }

            stopPlaying() {
                this.isPlaying = false;
                this.audioQueue = [];
                this.nextPlayTime = 0;
                this.scheduledChunks = 0;
                this.playbackStarted = false;
                if (this.audioContext) {
                    this.audioContext.close();
                    this.audioContext = null;
                    this.gainNode = null;
                    this.compressor = null;
                    this.analyser = null;
                }
                log('Stopped playing audio');
            }

            disconnect() {
                this.stopPlaying();
                if (this.ws) {
                    this.ws.close();
                    this.ws = null;
                }
            }
        }

        const player = new AudioStreamPlayer();
        let durationInterval = null;

        function updateStatus(status, isConnected) {
            document.getElementById('connectionStatus').textContent = status;
            const indicator = document.getElementById('statusIndicator');
            indicator.className = 'status-indicator ' + (isConnected ? 'connected' : 'disconnected');

            const playButton = document.getElementById('playButton');
            playButton.disabled = !isConnected && status !== 'Disconnected';
        }

        function updatePlayButton() {
            const button = document.getElementById('playButton');
            if (player.isPlaying) {
                button.textContent = 'Stop';
                button.classList.add('playing');
            } else {
                button.textContent = 'Connect & Play';
                button.classList.remove('playing');
            }
        }

        function updateDuration() {
            if (durationInterval) clearInterval(durationInterval);

            if (player.isPlaying) {
                durationInterval = setInterval(() => {
                    const elapsed = Math.floor((Date.now() - player.startTime) / 1000);
                    const minutes = Math.floor(elapsed / 60);
                    const seconds = elapsed % 60;
                    document.getElementById('duration').textContent =
                        `${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}`;
                }, 1000);
            }
        }

        function log(message, type = 'info') {
            const logArea = document.getElementById('logArea');
            const timestamp = new Date().toLocaleTimeString();
            const entry = document.createElement('div');
            entry.className = 'log-entry';
            entry.innerHTML = `<span class="log-timestamp">[${timestamp}]</span> ${message}`;
            logArea.appendChild(entry);
            logArea.scrollTop = logArea.scrollHeight;
        }

        function visualize(analyser) {
            const canvas = document.getElementById('audioCanvas');
            const canvasCtx = canvas.getContext('2d');
            canvas.width = canvas.offsetWidth;
            canvas.height = canvas.offsetHeight;

            const bufferLength = analyser.frequencyBinCount;
            const dataArray = new Uint8Array(bufferLength);

            function draw() {
                requestAnimationFrame(draw);

                analyser.getByteTimeDomainData(dataArray);

                canvasCtx.fillStyle = 'rgb(0, 0, 0)';
                canvasCtx.fillRect(0, 0, canvas.width, canvas.height);

                canvasCtx.lineWidth = 2;
                canvasCtx.strokeStyle = 'rgb(0, 255, 0)';
                canvasCtx.beginPath();

                const sliceWidth = canvas.width / bufferLength;
                let x = 0;

                for (let i = 0; i < bufferLength; i++) {
                    const v = dataArray[i] / 128.0;
                    const y = v * canvas.height / 2;

                    if (i === 0) {
                        canvasCtx.moveTo(x, y);
                    } else {
                        canvasCtx.lineTo(x, y);
                    }

                    x += sliceWidth;
                }

                canvasCtx.lineTo(canvas.width, canvas.height / 2);
                canvasCtx.stroke();
            }

            draw();
        }

        // Event listeners
        document.getElementById('playButton').addEventListener('click', async () => {
            if (player.isPlaying) {
                player.stopPlaying();
            } else {
                await player.startPlaying();
            }
            updatePlayButton();
        });

        // Volume slider event listener
        document.getElementById('volumeSlider').addEventListener('input', (e) => {
            const volume = e.target.value / 100;  // Convert 0-100 to 0.0-1.0
            player.setVolume(volume);
            document.getElementById('volumeValue').textContent = `${e.target.value}%`;
        });

        // Settings event listeners
        function showSettingsMessage(message, type = 'success') {
            const statusDiv = document.getElementById('settingsStatus');
            statusDiv.textContent = message;
            statusDiv.style.display = 'block';
            statusDiv.style.background = type === 'success' ? '#d4edda' : '#f8d7da';
            statusDiv.style.color = type === 'success' ? '#155724' : '#721c24';
            statusDiv.style.border = type === 'success' ? '1px solid #c3e6cb' : '1px solid #f5c6cb';

            setTimeout(() => {
                statusDiv.style.display = 'none';
            }, 3000);
        }

        document.getElementById('saveSettingsBtn').addEventListener('click', () => {
            const settings = {
                volume: parseInt(document.getElementById('settingsVolume').value),
                startupBuffer: parseInt(document.getElementById('settingsStartupBuffer').value),
                recoveryBuffer: parseInt(document.getElementById('settingsRecoveryBuffer').value)
            };

            // Validate settings
            if (settings.volume < 0 || settings.volume > 100) {
                showSettingsMessage('Volume must be between 0 and 100', 'error');
                return;
            }
            if (settings.startupBuffer < 0 || settings.startupBuffer > 1000) {
                showSettingsMessage('Startup buffer must be between 0 and 1000ms', 'error');
                return;
            }
            if (settings.recoveryBuffer < 0 || settings.recoveryBuffer > 500) {
                showSettingsMessage('Recovery buffer must be between 0 and 500ms', 'error');
                return;
            }

            if (saveSettings(settings)) {
                showSettingsMessage('Settings saved! Refresh the page to apply changes.', 'success');

                // Update volume slider immediately
                player.setVolume(settings.volume / 100);
                document.getElementById('volumeSlider').value = settings.volume;
                document.getElementById('volumeValue').textContent = `${settings.volume}%`;
            } else {
                showSettingsMessage('Failed to save settings', 'error');
            }
        });

        document.getElementById('resetSettingsBtn').addEventListener('click', () => {
            const defaults = resetSettings();
            applySettingsToUI(defaults);
            showSettingsMessage('Settings reset to defaults! Refresh the page to apply changes.', 'success');
        });

        // Test Audio button
        document.getElementById('testAudioButton').addEventListener('click', async () => {
            const button = document.getElementById('testAudioButton');
            const originalText = button.textContent;
            button.disabled = true;
            button.textContent = '⏳ Testing...';

            try {
                const response = await fetch('/test-audio');
                const result = await response.json();
                if (result.status === 'success') {
                    log('✅ Test audio started');
                    button.textContent = '✅ Test Started';
                    setTimeout(() => {
                        button.textContent = originalText;
                        button.disabled = false;
                    }, 2000);
                } else {
                    log(`❌ Test audio failed: ${result.message}`, 'error');
                    button.textContent = '❌ Failed';
                    setTimeout(() => {
                        button.textContent = originalText;
                        button.disabled = false;
                    }, 2000);
                }
            } catch (error) {
                log(`❌ Error starting test: ${error.message}`, 'error');
                button.textContent = '❌ Error';
                setTimeout(() => {
                    button.textContent = originalText;
                    button.disabled = false;
                }, 2000);
            }
        });

        // Initialize
        log('WSS Raw Media Tap initialized');
        log('Click "Connect & Play" to start streaming audio');

        // Load and apply saved settings
        const savedSettings = loadSettings();
        applySettingsToUI(savedSettings);

        // Auto-connect on load
        window.addEventListener('load', () => {
            setTimeout(() => {
                player.connect();
            }, 1000);
        });

        // Function to fetch and update active calls table
        async function updateCallsTable() {
            try {
                const response = await fetch('/api/streams');
                const data = await response.json();

                const tbody = document.getElementById('callsTableBody');
                const countSpan = document.getElementById('callCount');

                countSpan.textContent = data.total_streams;

                if (data.streams.length === 0) {
                    tbody.innerHTML = `
                        <tr>
                            <td colspan="6" style="text-align: center; padding: 20px; color: #888;">
                                No active calls. Waiting for connections...
                            </td>
                        </tr>
                    `;
                } else {
                    tbody.innerHTML = data.streams.map(stream => {
                        const minutes = Math.floor(stream.duration / 60);
                        const seconds = stream.duration % 60;
                        const durationStr = `${minutes}:${seconds.toString().padStart(2, '0')}`;
                        const bytesKB = (stream.bytes_received / 1024).toFixed(1);
                        const isPlaying = stream.is_playing;

                        return `
                            <tr class="${isPlaying ? 'playing' : ''}" data-index="${stream.index}">
                                <td>${stream.id}</td>
                                <td>${stream.encoding}</td>
                                <td>${stream.sample_rate} Hz</td>
                                <td>${durationStr}</td>
                                <td>${bytesKB} KB</td>
                                <td>
                                    <button class="call-action-btn ${isPlaying ? 'listening' : 'listen'}"
                                            onclick="selectStream(${stream.index})"
                                            ${isPlaying ? 'disabled' : ''}>
                                        ${isPlaying ? '🔊 Listening' : '▶️ Listen'}
                                    </button>
                                </td>
                            </tr>
                        `;
                    }).join('');
                }
            } catch (error) {
                console.error('Error fetching streams:', error);
            }
        }

        // Function to select a stream
        async function selectStream(index) {
            try {
                const response = await fetch(`/api/select-stream?index=${index}`);
                const result = await response.json();
                if (result.status === 'success') {
                    log(`Switched to call: ${result.stream_id}`);
                    updateCallsTable(); // Refresh immediately
                }
            } catch (error) {
                log(`Error switching stream: ${error.message}`, 'error');
            }
        }

        // Start auto-refresh every 2 seconds
        setInterval(updateCallsTable, 2000);
        // Initial load
        updateCallsTable();
    </script>
</body>
</html>
